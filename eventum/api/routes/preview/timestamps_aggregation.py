"""Utils for aggregation of timestamps generated by input plugins."""

from datetime import timedelta

import numpy as np
from numpy.typing import NDArray

from eventum.api.routes.preview.models import AggregatedTimestamps

_AUTO_SPANS_US = np.array(
    [
        1,  # 1s
        5,  # 5s
        10,  # 10s
        15,  # 15s
        30,  # 30s
        60,  # 1m
        300,  # 5m
        600,  # 10m
        900,  # 15m
        1800,  # 30m
        3600,  # 1h
        7200,  # 2h
        14400,  # 4h
        21600,  # 6h
        43200,  # 12h
        86400,  # 1d
        604800,  # 7d
        2592000,  # 30d
    ],
    dtype='timedelta64[s]',
).astype('timedelta64[us]')

_OPTIMAL_SPANS_COUNT = 60


def calculate_auto_span(
    earliest_ts: np.datetime64,
    latest_ts: np.datetime64,
    timestamps_count: int,
    optimal_spans_count: int,
) -> np.timedelta64:
    """Calculate optimal span for time distribution with provided
    parameters.

    Parameters
    ----------
    earliest_ts : np.datetime64
        Earliest timestamp in the distribution.

    latest_ts : np.datetime64
        Latest timestamp in the distribution.

    timestamps_count : int
        Count of timestamps in the distribution.

    optimal_spans_count : int
        Optimal count of span for aggregated distribution.

    Returns
    -------
    np.timedelta64
        Calculated span.

    Notes
    -----
    Resulting span won't necessarily be equal to value calculated from
    `optimal_spans_count`, because it is also aligned to one of nice
    spans that satisfies condition of the nearest smaller.

    """
    optimal_span = np.timedelta64(
        (latest_ts - earliest_ts) / min(optimal_spans_count, timestamps_count),
        'us',
    )

    indexes = np.where(optimal_span >= _AUTO_SPANS_US)[0]
    index = indexes[-1] if indexes.size > 0 else 0
    return _AUTO_SPANS_US[index]


def aggregate_timestamps(
    timestamps: NDArray[np.datetime64],
    span: timedelta | None,
) -> AggregatedTimestamps:
    """Aggregate timestamps into fixed, aligned spans.

    Parameters
    ----------
    timestamps : NDArray[np.datetime64[us]]
        Array of timestamps.

    span : timedelta | None
        Span duration. In case `None` is provided auto span is used.

    Returns
    -------
    AggregatedTimestamps
        Aggregated timestamps.

    """
    if timestamps.size == 0:
        return AggregatedTimestamps(span_edges=[], span_counts=[])

    if span is None:
        span_td64 = calculate_auto_span(
            earliest_ts=timestamps.min(),
            latest_ts=timestamps.max(),
            timestamps_count=timestamps.size,
            optimal_spans_count=_OPTIMAL_SPANS_COUNT,
        )
    else:
        span_td64 = np.timedelta64(span, 'us')

    origin = np.datetime64('1970-01-01', 'us')
    existing_spans = (timestamps - origin) // span_td64

    min_span, max_span = existing_spans.min(), existing_spans.max()
    all_spans: NDArray = np.arange(min_span, max_span + 1)

    counts = np.bincount(existing_spans - min_span, minlength=all_spans.size)
    bin_edges: NDArray = all_spans * span_td64 + origin

    return AggregatedTimestamps(
        span_edges=bin_edges.tolist(),  # type: ignore[arg-type]
        span_counts=counts.tolist(),  # type: ignore[arg-type]
    )
