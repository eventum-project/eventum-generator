"""Utils for aggregation of timestamps generated by input plugins."""

from datetime import timedelta
from typing import TYPE_CHECKING

import numpy as np

from eventum.api.routers.preview.models import AggregatedTimestamps
from eventum.plugins.input.protocols import IdentifiedTimestamps

if TYPE_CHECKING:
    from numpy.typing import NDArray

_AUTO_SPANS_US = np.array(
    [
        1,  # 1s
        5,  # 5s
        10,  # 10s
        15,  # 15s
        30,  # 30s
        60,  # 1m
        300,  # 5m
        600,  # 10m
        900,  # 15m
        1800,  # 30m
        3600,  # 1h
        7200,  # 2h
        14400,  # 4h
        21600,  # 6h
        43200,  # 12h
        86400,  # 1d
        604800,  # 7d
        2592000,  # 30d
    ],
    dtype='timedelta64[s]',
).astype('timedelta64[us]')

_OPTIMAL_SPANS_COUNT = 30

_MAX_FULLY_RETURNED_TIMESTAMPS_SAMPLE_SIZE = 100


def calculate_auto_span(
    earliest_ts: np.datetime64,
    latest_ts: np.datetime64,
    timestamps_count: int,
    optimal_spans_count: int,
) -> np.timedelta64:
    """Calculate optimal span for time distribution with provided
    parameters.

    Parameters
    ----------
    earliest_ts : np.datetime64
        Earliest timestamp in the distribution.

    latest_ts : np.datetime64
        Latest timestamp in the distribution.

    timestamps_count : int
        Count of timestamps in the distribution.

    optimal_spans_count : int
        Optimal count of span for aggregated distribution.

    Returns
    -------
    np.timedelta64
        Calculated span.

    Notes
    -----
    Resulting span won't necessarily be equal to value calculated from
    `optimal_spans_count`, because it is also aligned to one of nice
    spans that satisfies condition of the nearest smaller.

    """
    optimal_span = np.timedelta64(
        (latest_ts - earliest_ts) / min(optimal_spans_count, timestamps_count),
        'us',
    )

    indexes = np.where(optimal_span >= _AUTO_SPANS_US)[0]
    index = indexes[-1] if indexes.size > 0 else 0
    return _AUTO_SPANS_US[index]


def aggregate_timestamps(
    timestamps: IdentifiedTimestamps,
    span: timedelta | None,
) -> AggregatedTimestamps:
    """Aggregate timestamps by fixed aligned time spans and plugins ids.

    Parameters
    ----------
    timestamps : IdentifiedTimestamps
        Record array of timestamps and input plugin ids.

    span : timedelta | None
        Span duration. In case `None` is provided auto span is used.

    Returns
    -------
    AggregatedTimestamps
        Aggregated timestamps.

    """
    plugin_ids = timestamps['id']
    timestamps = timestamps['timestamp']

    if timestamps.size == 0:
        return AggregatedTimestamps(
            span_edges=[],
            span_counts={},
            total=0,
            first_timestamps=None,
            last_timestamps=None,
            timestamps=[],
        )

    if span is None:
        span_td64 = calculate_auto_span(
            earliest_ts=timestamps.min(),
            latest_ts=timestamps.max(),
            timestamps_count=timestamps.size,
            optimal_spans_count=_OPTIMAL_SPANS_COUNT,
        )
    else:
        span_td64 = np.timedelta64(span, 'us')

    # calculate span edges
    origin = np.datetime64('1970-01-01', 'us')

    timestamp_spans = (timestamps - origin) // span_td64
    min_span, max_span = timestamp_spans.min(), timestamp_spans.max()
    all_spans: NDArray = np.arange(min_span, max_span + 1)

    span_edges: NDArray = all_spans * span_td64 + origin

    # aggregate: count by time span, plugin ids
    counts, _, _ = np.histogram2d(
        timestamp_spans - min_span,
        plugin_ids,
        bins=(all_spans.size, plugin_ids.max()),
        range=[[0, all_spans.size], [1, plugin_ids.max() + 1]],
    )
    span_counts = {
        plugin_id: plugin_counts.tolist()
        for plugin_id, plugin_counts in enumerate(counts.T, start=1)
    }

    if timestamps.size <= _MAX_FULLY_RETURNED_TIMESTAMPS_SAMPLE_SIZE:
        first_timestamps = None
        last_timestamps = None
        all_timestamps = timestamps.tolist()
    else:
        first_timestamps = timestamps[:50].tolist()
        last_timestamps = timestamps[-50:].tolist()
        all_timestamps = None

    return AggregatedTimestamps(
        span_edges=span_edges.tolist(),  # type: ignore[arg-type]
        span_counts=span_counts,
        total=timestamps.size,
        first_timestamps=first_timestamps,  # type: ignore[arg-type]
        last_timestamps=last_timestamps,  # type: ignore[arg-type]
        timestamps=all_timestamps,  # type: ignore[arg-type]
    )
